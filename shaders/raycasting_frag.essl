precision highp sampler3D;

uniform sampler3D volume;
uniform sampler2D frontCube;
uniform sampler2D backCube;
uniform float iso;

varying vec3 vPosition;
varying vec2 texCoord;

//values for interactive transferfunction
uniform int opacityLen;
const int CONTROLPOINTS = 10;
uniform vec2 opacity[CONTROLPOINTS];

const int STEPS = 512; 

//calculate the channel color/opacity
float applyTransferFunction(float density, vec2 points[CONTROLPOINTS], int size){

	float value = 0.0;	
	
	for (int i = 0; i < size-1; i++){

		vec2 current = points[i];
		vec2 next = points[i+1];

		if (density >= current.x && density < next.x){
            //float ratio = (density - current.x) / (next.x - current.x); 
			value = mix(current.y, next.y, density);
            break; 
		}

	}
	return value;
}


void main(){
    vec3 uvw = vec3(vPosition.x, vPosition.y ,vPosition.z);
    vec3 start = texture(frontCube, texCoord).rgb;
    vec3 end = texture(backCube, texCoord).rgb;
    vec3 ray = end - start;
    float rayLenSquared = dot(ray, ray);

    // no volume intersection
    if (rayLenSquared < 0.000001) {
        gl_FragColor = vec4(0.0);
        return;
    }

    vec3 dir = normalize(ray);
    float stepSize = max(rayLenSquared / float(STEPS), 0.005);
    vec3 step = dir * vec3(stepSize);
    //float endDist = dot(end, end);
    //float startDist = dot(start, start);

    // render bounding cube
    //gl_FragColor = vec4(vec3(rayLenSquared * 0.5), 1.0);

    vec3 color = vec3(0);
    //vec3 voxelColor = vec3(0.8, 0.3, 0.3);

    vec3 rayPosPrev = start;
    float voxelPrev = texture(volume, rayPosPrev.xyz).r;

    vec3 rayPosCurr;
    float voxelCurr;

    //variables for alpha compositing
    vec3 colCurr;
    vec3 colAcc = vec3(0);
    vec3 colOut;
    float alphaCurr;
    float alphaAcc = 0.0;
    float alphaOut;
    //


    for (int i = 0; i < STEPS; i++) {

        rayPosCurr = rayPosPrev + step;
        voxelCurr = texture(volume, rayPosCurr.xyz).r;

        vec3 insideRay = rayPosCurr - start;
        if(dot(insideRay, insideRay) > rayLenSquared) break;

        //---alpha compositing, Front-to-Back with early ray termination
	    float a = applyTransferFunction(voxelCurr, opacity, opacityLen);
        //colCurr = vec3(r,g,b);
        colCurr = vec3(1.0, 0.5, 0.0); 
        alphaCurr = a;

        colOut = colCurr * alphaCurr * (1.0-alphaAcc) + colAcc;
        alphaOut = min(alphaCurr * (1.0-alphaAcc) + alphaAcc, 1.0);

        colAcc = colOut;
        alphaAcc = alphaOut;

        // early ray termination 
        if(alphaAcc > 0.99) break;
        //---

        rayPosPrev = rayPosCurr;

    }
    //gl_FragColor = vec4(colAcc, alphaAcc);
    vec3 testAlpha = vec3(alphaAcc); 
    gl_FragColor = vec4(testAlpha, alphaAcc); 
}