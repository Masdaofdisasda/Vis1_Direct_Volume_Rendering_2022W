precision highp sampler3D;

uniform sampler3D volume;
uniform sampler2D frontCube;
uniform sampler2D backCube;
uniform float iso;

varying vec3 vPosition;
varying vec2 texCoord;

//values for interactive transferfunction
uniform int len;
const int CONTROLPOINTS = 10;
uniform vec2 opacity[CONTROLPOINTS];
uniform vec3 colors[CONTROLPOINTS]; 

const int STEPS = 1024; 


vec3 getColor(float ratio, int i){
    vec3 c = vec3(1.0);

    if(i >= 0){
        c = mix(colors[i], colors[i+1], ratio); 
    }

    return c; 
}

float getOpacity(float ratio, int i){
    float value = 0.0;	

    if(i >= 0){
        vec2 current = opacity[i];
	    vec2 next = opacity[i+1];
        value = mix(current.y, next.y, ratio);
    }

    return value; 
}

float getRatio(float density, int i){
    float ratio = 0.0; 

    if(i >= 0){
        vec2 current = opacity[i];
	    vec2 next = opacity[i+1];

        ratio = (density - current.x) / (next.x - current.x); 
    }
    
    return ratio; 
}

int getControlPointIndex(float density){
    float value = 0.0;	
	
	for (int i = 0; i < len-1; i++){

		vec2 current = opacity[i];
		vec2 next = opacity[i+1];

		if (density >= current.x && density < next.x){
            return i; 
		}

	}
	return -1;
}


void main(){
    vec3 uvw = vec3(vPosition.x, vPosition.y ,vPosition.z);
    vec3 start = texture(frontCube, texCoord).rgb;
    vec3 end = texture(backCube, texCoord).rgb;
    vec3 ray = end - start;
    float rayLenSquared = dot(ray, ray);

    // no volume intersection
    if (rayLenSquared < 0.000001) {
        gl_FragColor = vec4(0.0);
        return;
    }

    vec3 dir = normalize(ray);
    float stepSize = max(rayLenSquared / float(STEPS), 0.005);
    vec3 step = dir * vec3(stepSize);

    // render bounding cube
    //gl_FragColor = vec4(vec3(rayLenSquared * 0.5), 1.0);

    vec3 color = vec3(0);
    //vec3 voxelColor = vec3(0.8, 0.3, 0.3);

    vec3 rayPosPrev = start;
    float voxelPrev = texture(volume, rayPosPrev.xyz).r;

    vec3 rayPosCurr;
    float voxelCurr;

    //variables for alpha compositing
    vec3 colCurr;
    vec3 colAcc = vec3(0);
    vec3 colOut;
    float alphaCurr;
    float alphaAcc = 0.0;
    float alphaOut;
    //


    for (int i = 0; i < STEPS; i++) {

        rayPosCurr = rayPosPrev + step;
        voxelCurr = texture(volume, rayPosCurr.xyz).r;

        vec3 insideRay = rayPosCurr - start;
        if(dot(insideRay, insideRay) > rayLenSquared) break;

        //---alpha compositing, Front-to-Back with early ray termination
        int cpi = getControlPointIndex(voxelCurr); 
        float ratio = getRatio(voxelCurr, cpi); 
        float a = getOpacity(ratio, cpi); 
        colCurr = getColor(ratio, cpi); 
        //colCurr = vec3(1.0, 0.5, 0.0); 
        alphaCurr = a;

        colOut = colCurr * alphaCurr * (1.0-alphaAcc) + colAcc;
        alphaOut = min(alphaCurr * (1.0-alphaAcc) + alphaAcc, 1.0);

        colAcc = colOut;
        alphaAcc = alphaOut;

        // early ray termination 
        if(alphaAcc > 0.99) break;
        //---

        rayPosPrev = rayPosCurr;

    }
    gl_FragColor = vec4(colAcc, alphaAcc);
    //vec3 testAlpha = vec3(alphaAcc); 
    //gl_FragColor = vec4(testAlpha, alphaAcc); 
}